const bd = require('binary-data')
const leb128 = require('types/leb128/signed')
const uleb128 = require('types/leb128/unsigned')
const until = require('types/until')

const { types: { uint8, uint32le, buffer, when, array, select, string } } = bd;

const varuint1 = uleb128(1)
const varuint7 = uleb128(7)
const varuint32 = uleb128(32)
const varint7 = leb128(7)

const Module = {
  magic: uint32le,
  version: uint32le
}

const Name = {
  length: varuint32,
  data: string(({ current }) => current.length.toNumber())
}

function ondata({ current }) {
  const length = current.length.toNumber()

  if (current.id.isZero()) {
    return length - current.name.data.length - current.name.length.byteLength()
  }

  return length
}

const resizable_limits = {
  flags: varuint1,
  initial: varuint32,
  maximum: when(({ current }) => !current.flags.isZero(), varuint32)
}

const value_type = varint7
const block_type = varint7
const elem_type = varint7

const func_type = {
  form: varint7,
  param: {
    count: varuint32,
    types: array(value_type, ({ current }) => current.count.toNumber())
  },
  return: {
    count: varuint1,
    type: when(({ current }) => current.count.eqn(1), value_type)
  }
}

const global_type = {
  content_type: value_type,
  mutability: varuint1
}

const table_type = {
  element_type: elem_type,
  limits: resizable_limits
}

const memory_type = {
  limits: resizable_limits
}

const external_kind = uint8

const init_expr = {
  code: buffer(until(0x0b)),
  end: uint8
}

const export_entry = {
  length: varuint32,
  name: string(({ current }) => current.length.toNumber()),
  kind: external_kind,
  index: varuint32
}

const local_entry = {
  count: varuint32,
  type: value_type
}

const function_body_locals = {
  count: varuint32,
  types: array(local_entry, ({ current }) => current.count.toNumber())
}

/**
 * Special internal type to work with function_body.
 */
function body() {
  function decode(rstream) {
    decode.bytes = 0

    const size = bd.decode(rstream, varuint32)
    decode.bytes += bd.decode.bytes

    const locals = bd.decode(rstream, function_body_locals)
    decode.bytes += bd.decode.bytes

    const codeBytes = size.toNumber() - bd.decode.bytes - 1
    const code = bd.decode(rstream, buffer(codeBytes))
    decode.bytes += bd.decode.bytes

    rstream.readUInt8()
    decode.bytes += 1

    return {
      size,
      locals,
      code
    }
  }

  return {
    encode() {},
    decode
  }
}

const import_entry = {
  module: {
    length: varuint32,
    name: string(({ current }) => current.length.toNumber()),
  },
  field: {
    length: varuint32,
    name: string(({ current }) => current.length.toNumber()),
  },
  kind: external_kind,
  type: select(
    when(({ current }) => current.kind === 0, varuint32),
    when(({ current }) => current.kind === 1, table_type),
    when(({ current }) => current.kind === 2, memory_type),
    when(({ current }) => current.kind === 3, global_type)
  )
}

// Type section, id=1
const SectionType = {
  count: varuint32,
  entries: array(func_type, ({ current }) => current.count.toNumber())
}

// Import section, id=2
const SectionImport = {
  count: varuint32,
  entries: array(import_entry, ({ current }) => current.count.toNumber())
}

// Function section, id=3
const SectionFunction = {
  count: varuint32,
  types: array(varuint32, ({ current }) => current.count.toNumber())
}

// Table section, id=4
const SectionTable = {
  count: varuint32,
  entries: array(table_type, ({ current }) => current.count.toNumber())
}

// Memory section, id=5
const SectionMemory = {
  count: varuint32,
  entries: array(memory_type, ({ current }) => current.count.toNumber())
}

const global_variable = {
  type: global_type,
  init: init_expr
}

// Global section, id=6
const SectionGlobal = {
  count: varuint32,
  globals: array(global_variable, ({ current }) => current.count.toNumber())
}

// Export section, id=7
const SectionExport = {
  count: varuint32,
  entries: array(export_entry, ({ current }) => current.count.toNumber())
}

// Start section, id=8
const SectionStart = {
  index: varuint32
}

const elem_segment = {
  index: varuint32,
  offset: init_expr,
  elements: {
    count: varuint32,
    list: array(varuint32, ({ current }) => current.count.toNumber())
  }
}

// Element section, id=9
const SectionElement = {
  count: varuint32,
  entries: array(elem_segment, ({ current }) => current.count.toNumber())
}

// Code section, id=10
const SectionCode = {
  count: varuint32,
  bodies: array(body(), ({ current }) => current.count.toNumber())
}

const data_segment = {
  index: varuint32,
  offset: init_expr,
  size: varuint32,
  data: buffer(({ current }) => current.size.toNumber())
}

// Data section, id=11
const SectionData = {
  count: varuint32,
  entries: array(data_segment, ({ current }) => current.count.toNumber())
}

const Section = {
  id: varuint7,
  length: varuint32,
  name: when(({ node }) => node.id.isZero(), Name),
  data: select(
    when(({ node }) => node.id.eqn(1), SectionType),
    when(({ node }) => node.id.eqn(2), SectionImport),
    when(({ node }) => node.id.eqn(3), SectionFunction),
    when(({ node }) => node.id.eqn(4), SectionTable),
    when(({ node }) => node.id.eqn(5), SectionMemory),
    when(({ node }) => node.id.eqn(6), SectionGlobal),
    when(({ node }) => node.id.eqn(7), SectionExport),
    when(({ node }) => node.id.eqn(8), SectionStart),
    when(({ node }) => node.id.eqn(9), SectionElement),
    when(({ node }) => node.id.eqn(10), SectionCode),
    when(({ node }) => node.id.eqn(11), SectionData),
    buffer(ondata)
  )
}

module.exports = {
  Module,
  Section,
}
