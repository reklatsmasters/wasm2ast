const { types: { uint8, uint32le, buffer, when, array, select } } = require('binary-data')
const leb128 = require('types/leb128/signed')
const uleb128 = require('types/leb128/unsigned')
const until = require('types/until')

const varuint1 = uleb128(1)
const varuint7 = uleb128(7)
const varuint32 = uleb128(32)
const varint7 = leb128(7)

const Module = {
  magic: uint32le,
  version: uint32le
}

const Name = {
  length: varuint32,
  data: buffer(({ currentNode }) => currentNode.length.toNumber())
}

function ondata({ node }) {
  const length = node.length.toNumber()

  if (node.id.isZero()) {
    return length - node.name.data.length - node.name.length.byteLength()
  }

  return length
}

const resizable_limits = {
  flags: varuint1,
  initial: varuint32,
  maximum: when(({ currentNode }) => !currentNode.flags.isZero(), varuint32)
}

const value_type = varint7
const block_type = varint7
const elem_type = varint7

const func_type = {
  form: varint7,
  param: {
    count: varuint32,
    types: array(value_type, ({ currentNode }) => currentNode.count.toNumber())
  },
  return: {
    count: varuint1,
    type: when(({ currentNode }) => currentNode.count.eqn(1), value_type)
  }
}

const global_type = {
  content_type: value_type,
  mutability: varuint1
}

const table_type = {
  element_type: elem_type,
  limits: resizable_limits
}

const memory_type = {
  limits: resizable_limits
}

const external_kind = uint8

const init_expr = {
  code: buffer(until(0x0b)),
  end: uint8
}

const export_entry = {
  length: varuint32,
  name: buffer(({ currentNode }) => currentNode.length.toNumber()),
  kind: external_kind,
  index: varuint32
}

const local_entry = {
  count: varuint32,
  type: value_type
}

const function_body = {
  size: varuint32,
  locals: {
    count: varuint32,
    types: array(local_entry, ({ currentNode }) => currentNode.count.toNumber())
  },
  code: buffer(onFunctionCodeSize),
  end: uint8
}

function onFunctionCodeSize({ currentNode }) {
  let size = currentNode.size.toNumber()

  size -= (currentNode.locals.count.byteLength() || 1)

  for (const entry of currentNode.locals.types) {
    size -= (entry.count.byteLength() || 1)
    size -= 1
  }

  return size - 1
}

const import_entry = {
  module: {
    length: varuint32,
    name: buffer(({ currentNode }) => currentNode.length.toNumber()),
  },
  field: {
    length: varuint32,
    name: buffer(({ currentNode }) => currentNode.length.toNumber()),
  },
  kind: external_kind,
  type: select(
    when(({ currentNode }) => currentNode.kind === 0, varuint32),
    when(({ currentNode }) => currentNode.kind === 1, table_type),
    when(({ currentNode }) => currentNode.kind === 2, memory_type),
    when(({ currentNode }) => currentNode.kind === 3, global_type)
  )
}

// Type section, id=1
const SectionType = {
  count: varuint32,
  entries: array(func_type, ({ currentNode }) => currentNode.count.toNumber())
}

// Import section, id=2
const SectionImport = {
  count: varuint32,
  entries: array(import_entry, ({ currentNode }) => currentNode.count.toNumber())
}

// Function section, id=3
const SectionFunction = {
  count: varuint32,
  types: array(varuint32, ({ currentNode }) => currentNode.count.toNumber())
}

// Table section, id=4
const SectionTable = {
  count: varuint32,
  entries: array(table_type, ({ currentNode }) => currentNode.count.toNumber())
}

// Memory section, id=5
const SectionMemory = {
  count: varuint32,
  entries: array(memory_type, ({ currentNode }) => currentNode.count.toNumber())
}

const global_variable = {
  type: global_type,
  init: init_expr
}

// Global section, id=6
const SectionGlobal = {
  count: varuint32,
  globals: array(global_variable, ({ currentNode }) => currentNode.count.toNumber())
}

// Export section, id=7
const SectionExport = {
  count: varuint32,
  entries: array(export_entry, ({ currentNode }) => currentNode.count.toNumber())
}

// Start section, id=8
const SectionStart = {
  index: varuint32
}

const elem_segment = {
  index: varuint32,
  offset: init_expr,
  elements: {
    count: varuint32,
    list: array(varuint32, ({ currentNode }) => currentNode.count.toNumber())
  }
}

// Element section, id=9
const SectionElement = {
  count: varuint32,
  entries: array(elem_segment, ({ currentNode }) => currentNode.count.toNumber())
}

// Code section, id=10
const SectionCode = {
  count: varuint32,
  bodies: array(function_body, ({ currentNode }) => currentNode.count.toNumber())
}

const data_segment = {
  index: varuint32,
  offset: init_expr,
  size: varuint32,
  data: buffer(({ currentNode }) => currentNode.size.toNumber())
}

// Data section, id=11
const SectionData = {
  count: varuint32,
  entries: array(data_segment, ({ currentNode }) => currentNode.count.toNumber())
}

const Section = {
  id: varuint7,
  length: varuint32,
  name: when(({ node }) => node.id.isZero(), Name),
  data: select(
    when(({ node }) => node.id.eqn(1), SectionType),
    when(({ node }) => node.id.eqn(2), SectionImport),
    when(({ node }) => node.id.eqn(3), SectionFunction),
    when(({ node }) => node.id.eqn(4), SectionTable),
    when(({ node }) => node.id.eqn(5), SectionMemory),
    when(({ node }) => node.id.eqn(6), SectionGlobal),
    when(({ node }) => node.id.eqn(7), SectionExport),
    when(({ node }) => node.id.eqn(8), SectionStart),
    when(({ node }) => node.id.eqn(9), SectionElement),
    when(({ node }) => node.id.eqn(10), SectionCode),
    when(({ node }) => node.id.eqn(11), SectionData),
    buffer(ondata)
  )
}

module.exports = {
  Module,
  Section,
}
